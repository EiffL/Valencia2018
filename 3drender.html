<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
    <style>
    body{
      font-family: source-code-pro, sans-serif;
      color:#F9F9F9;
      background-color: #212121
    }

    #r3d {
      background-color: #212121;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      position: absolute;
      width: 100%;
      height: 100%;
      overflow:hidden;
    }

    #my-gui-container {
      position: fixed;
      top: 30px;
      right: 20px;
      z-index:1;
    }

    #my-lut-container {
      display: none;
      position: fixed;
      left: 50%;
      transform: translate(-50%, 0);
      z-index: 1;
      color: #F9F9F9;
      text-align: center;
    }

    #my-lut-container > div > .my-tf {
      position: relative;
    }

    #my-lut-min {
      margin-right: 10px;
    }

    #my-lut-max {
      margin-left: 10px;
    }

    #my-lut-container > div {
      margin-bottom: 10px;
    }

    #my-lut-container > div > .my-tf > :first-child {
      background: repeating-linear-gradient(-45deg, #353535, #353535 5px, black 5px, black 10px);
    }

    #my-lut-container > div > .my-tf > :nth-child(2) {
      position: absolute;
      top: 0;
      left: 0;
    }
    </style>

	</head>
<body>
 <div id="my-gui-container"></div>

<div id="my-lut-container">
  <div>Transfer function<div id="my-tf" class="my-tf"></div></div>
</div>

<div id="r3d"></div>
 <script src="https://cdn.rawgit.com/dataarts/dat.gui/master/build/dat.gui.min.js"></script>
 <script src="https://cdn.rawgit.com/mrdoob/stats.js/master/build/stats.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/ami.js/0.0.22/ami.min.js"></script>

<script>

/* globals Stats, dat, AMI*/

// standard global letiables
var controls;
var threeD;
var renderer;
var stats;
var camera;
var scene;
var vrHelper;
var lut;
var ready = false;

var myStack = {
    lut: 'red',
    opacity: 'random',
    steps: 256,
    alphaCorrection: 0.5,
    interpolation: 1
};

/**
 * Handle mouse down event
 */
function onMouseDown() {
    if (vrHelper && vrHelper.uniforms) {
        vrHelper.uniforms.uSteps.value = Math.floor(myStack.steps / 2);
        vrHelper.interpolation = 0;
    }
}

/**
 * Handle mouse up event
 */
function onMouseUp() {
    if (vrHelper && vrHelper.uniforms) {
        vrHelper.uniforms.uSteps.value = myStack.steps;
        vrHelper.interpolation = myStack.interpolation;
    }
}

/**
 * Handle window resize event
 */
function onWindowResize() {
    // update the camera
    camera.aspect = threeD.offsetWidth / threeD.offsetHeight;
    camera.updateProjectionMatrix();

    // notify the renderer of the size change
    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);
}

/**
 * Build GUI
 */
function buildGUI() {
    var gui = new dat.GUI({
        autoPlace: false
    });

    var customContainer = document.getElementById('my-gui-container');
    customContainer.appendChild(gui.domElement);
    // Let's hide the container
    customContainer.style.display = 'none';

    var stackFolder = gui.addFolder('Settings');
    var lutUpdate = stackFolder.add(myStack, 'lut', lut.lutsAvailable());
    lutUpdate.onChange(function(value) {
        lut.lut = value;
        vrHelper.uniforms.uTextureLUT.value.dispose();
        vrHelper.uniforms.uTextureLUT.value = lut.texture;
    });
    // init LUT
    lut.lut = myStack.lut;
    vrHelper.uniforms.uTextureLUT.value.dispose();
    vrHelper.uniforms.uTextureLUT.value = lut.texture;

    var opacityUpdate = stackFolder.add(myStack, 'opacity', lut.lutsAvailable('opacity'));
    opacityUpdate.onChange(function(value) {
        lut.lutO = value;
        vrHelper.uniforms.uTextureLUT.value.dispose();
        vrHelper.uniforms.uTextureLUT.value = lut.texture;
    });

    var stepsUpdate = stackFolder.add(myStack, 'steps', 0, 512).step(1);
    stepsUpdate.onChange(function(value) {
        if (vrHelper.uniforms) {
            vrHelper.uniforms.uSteps.value = value;
        }
    });

    var alphaCorrrectionUpdate = stackFolder.add(myStack, 'alphaCorrection', 0, 1).step(0.01);
    alphaCorrrectionUpdate.onChange(function(value) {
        if (vrHelper.uniforms) {
            vrHelper.uniforms.uAlphaCorrection.value = value;
        }
    });

    stackFolder.add(vrHelper, 'interpolation', 0, 1).step(1);

}

/**
 * Init the scene
 */
function init() {
    /**
   * Rendering loop
   */
    function animate() {
        // render
        controls.update();

        if (ready) {
            renderer.render(scene, camera);
        }
        // request new frame
        requestAnimationFrame(function() {
            animate();
        });
    }

    // renderer
    threeD = document.getElementById('r3d');
    renderer = new THREE.WebGLRenderer({
        alpha: true
    });
    renderer.setSize(threeD.offsetWidth, threeD.offsetHeight);
    threeD.appendChild(renderer.domElement);

    // scene
    scene = new THREE.Scene();

    // camera
    camera = new THREE.PerspectiveCamera(45, threeD.offsetWidth / threeD.offsetHeight, 0.1, 100000);
    camera.position.x = -300;
    camera.position.y = 128;
    camera.position.z = 128;
    camera.lookAt(0., 0., 0.);

    // controls
    controls = new AMI.TrackballControl(camera, threeD);
    controls.rotateSpeed = 5.5;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;
    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;

    threeD.addEventListener('mousedown', onMouseDown, false);
    threeD.addEventListener('mouseup', onMouseUp, false);
    window.addEventListener('resize', onWindowResize, false);

    // start rendering loop
    animate();
		//
    // function animate(t) {
		//
    //     scene.rotation.y +=  0.01;
		//
    //     if (camera.position.z <= 200 && camera.position.z >= 5 )
    //       { camera.position.z -= 0.4 }
    //     else
    //       {  };
		//
    //     renderer.clear();
    //     camera.lookAt(scene.position);
    //     renderer.render(scene, camera);
    //     window.requestAnimationFrame(animate);
		//
    // };
    // window.requestAnimationFrame(animate);

}

// init threeJS...
init();

// Extracting the desired file
var url_string = window.location.href;
var url = new URL(url_string);
var file = url.searchParams.get("file");

var loader = new AMI.VolumeLoader(threeD);
loader.load(file).then(function() {
    var series = loader.data[0].mergeSeries(loader.data)[0];
    loader.free();
    loader = null;
    // get first stack from series
    var stack = series.stack[0];

    vrHelper = new AMI.VolumeRenderingHelper(stack);

    // scene
    scene.add(vrHelper);

		// Add a bounding box
    bbHelper = new AMI.BoundingBoxHelper(stack);

    // scene
    scene.add(bbHelper);

    // Add a sprite
    // var spritey = makeTextSprite( "RA", { fontsize: 32 });
		// scene.add( spritey );
    // spritey.position.set(0,128,0);
		//
    // var spritey = makeTextSprite( "DEC", { fontsize: 32 });
		// scene.add( spritey );
    // spritey.position.set(0,0,128);
		//
    // var spritey = makeTextSprite( "Z", { fontsize: 32 });
		// scene.add( spritey );
    // spritey.position.set(128,0,0);

    // CREATE LUT
    lut = new AMI.LutHelper('my-tf');
    lut.luts = AMI.LutHelper.presetLuts();
    lut.lutsO = AMI.LutHelper.presetLutsO();
    // update related uniforms
    vrHelper.uniforms.uTextureLUT.value = lut.texture;
    vrHelper.uniforms.uLut.value = 1;

    // update camrea's and interactor's target
    var centerLPS = stack.worldCenter();
    camera.lookAt(centerLPS.x, centerLPS.y, centerLPS.z);
    camera.updateProjectionMatrix();
    controls.target.set(centerLPS.x, centerLPS.y, centerLPS.z);

    // create GUI
    buildGUI();

    ready = true;
});


function makeTextSprite( message, parameters )
{
	if ( parameters === undefined ) parameters = {};

	var fontface = parameters.hasOwnProperty("fontface") ?
		parameters["fontface"] : "Arial";

	var fontsize = parameters.hasOwnProperty("fontsize") ?
		parameters["fontsize"] : 18;

	var borderThickness = parameters.hasOwnProperty("borderThickness") ?
		parameters["borderThickness"] : 4;

	var borderColor = parameters.hasOwnProperty("borderColor") ?
		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };

	var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
		parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

	//var spriteAlignment = parameters.hasOwnProperty("alignment") ?
	//	parameters["alignment"] : THREE.SpriteAlignment.topLeft;

	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	context.font = "Bold " + fontsize + "px " + fontface;

	// get size data (height depends only on font size)
	var metrics = context.measureText( message );
	var textWidth = metrics.width;

	// background color
	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
								  + backgroundColor.b + "," + backgroundColor.a + ")";
	// border color
	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
								  + borderColor.b + "," + borderColor.a + ")";

	context.lineWidth = borderThickness;
	// 1.4 is extra height factor for text below baseline: g,j,p,q.

	// text color
	context.fillStyle = "rgba(1.0, 1.0, 1.0, 1.0)";

	context.fillText( message, borderThickness, fontsize + borderThickness);

	// canvas contents will be used for a texture
	var texture = new THREE.Texture(canvas)
	texture.needsUpdate = true;

	var spriteMaterial = new THREE.SpriteMaterial(
		{ map: texture, useScreenCoordinates: false} );
	var sprite = new THREE.Sprite( spriteMaterial );
	sprite.scale.set(100,50,1.0);
	return sprite;
}
</script>
</body>
